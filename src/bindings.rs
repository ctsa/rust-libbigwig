/* automatically generated by rust-bindgen 0.59.2 */

pub type __int64_t = ::std::os::raw::c_longlong;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_off_t = __int64_t;
pub type size_t = __darwin_size_t;
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._extra as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
pub type CURLcode = ::std::os::raw::c_int;
pub type CURL = ::std::os::raw::c_void;
pub const bigWigFile_type_enum_BWG_FILE: bigWigFile_type_enum = 0;
pub const bigWigFile_type_enum_BWG_HTTP: bigWigFile_type_enum = 1;
pub const bigWigFile_type_enum_BWG_HTTPS: bigWigFile_type_enum = 2;
pub const bigWigFile_type_enum_BWG_FTP: bigWigFile_type_enum = 3;
#[doc = " The enumerated values that indicate the connection type used to access a file."]
pub type bigWigFile_type_enum = ::std::os::raw::c_uint;
#[doc = " @brief This structure holds the file pointers and buffers needed for raw access to local and remote files."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct URL_t {
    #[doc = "<A union holding curl and fp."]
    pub x: URL_t__bindgen_ty_1,
    #[doc = "<A void * pointing to memory of size bufSize."]
    pub memBuf: *mut ::std::os::raw::c_void,
    #[doc = "<Current position inside the file."]
    pub filePos: size_t,
    #[doc = "<Curent position inside the buffer."]
    pub bufPos: size_t,
    #[doc = "<The size of the buffer."]
    pub bufSize: size_t,
    #[doc = "<The actual size of the buffer used."]
    pub bufLen: size_t,
    #[doc = "<The connection type"]
    pub type_: bigWigFile_type_enum,
    #[doc = "<1 if the file is compressed, otherwise 0"]
    pub isCompressed: ::std::os::raw::c_int,
    #[doc = "<Only needed for remote connections. The original URL/filename requested, since we need to make multiple connections."]
    pub fname: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union URL_t__bindgen_ty_1 {
    #[doc = "<The FILE * file pointer for local files."]
    pub fp: *mut FILE,
}
#[test]
fn bindgen_test_layout_URL_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<URL_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(URL_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<URL_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(URL_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<URL_t__bindgen_ty_1>())).fp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(URL_t__bindgen_ty_1),
            "::",
            stringify!(fp)
        )
    );
}
#[test]
fn bindgen_test_layout_URL_t() {
    assert_eq!(
        ::std::mem::size_of::<URL_t>(),
        64usize,
        concat!("Size of: ", stringify!(URL_t))
    );
    assert_eq!(
        ::std::mem::align_of::<URL_t>(),
        8usize,
        concat!("Alignment of ", stringify!(URL_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<URL_t>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(URL_t), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<URL_t>())).memBuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(URL_t),
            "::",
            stringify!(memBuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<URL_t>())).filePos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(URL_t),
            "::",
            stringify!(filePos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<URL_t>())).bufPos as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(URL_t),
            "::",
            stringify!(bufPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<URL_t>())).bufSize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(URL_t),
            "::",
            stringify!(bufSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<URL_t>())).bufLen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(URL_t),
            "::",
            stringify!(bufLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<URL_t>())).type_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(URL_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<URL_t>())).isCompressed as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(URL_t),
            "::",
            stringify!(isCompressed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<URL_t>())).fname as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(URL_t),
            "::",
            stringify!(fname)
        )
    );
}
#[doc = " @brief A node within an R-tree holding the index for data."]
#[doc = ""]
#[doc = " Note that there are two types of nodes: leaf and twig. Leaf nodes point to where data actually is. Twig nodes point to additional index nodes, which may or may not be leaves. Each of these nodes has additional children, which may span multiple chromosomes/contigs."]
#[doc = ""]
#[doc = " With the start/end position, these positions refer specifically to the chromosomes specified in chrIdxStart/chrIdxEnd. Any chromosomes between these are completely spanned by a given child."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bwRTreeNode_t {
    #[doc = "<Is this node a leaf?"]
    pub isLeaf: u8,
    #[doc = "<The number of children of this node, all lists have this length."]
    pub nChildren: u16,
    #[doc = "<A list of the starting chromosome indices of each child."]
    pub chrIdxStart: *mut u32,
    #[doc = "<A list of the start position of each child."]
    pub baseStart: *mut u32,
    #[doc = "<A list of the end chromosome indices of each child."]
    pub chrIdxEnd: *mut u32,
    #[doc = "<A list of the end position of each child."]
    pub baseEnd: *mut u32,
    #[doc = "<For leaves, the offset to the on-disk data. For twigs, the offset to the child node."]
    pub dataOffset: *mut u64,
    #[doc = "<A union holding either size or child"]
    pub x: bwRTreeNode_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bwRTreeNode_t__bindgen_ty_1 {
    #[doc = "<Leaves only: The size of the data block."]
    pub size: *mut u64,
    #[doc = "<Twigs only: The child node(s)."]
    pub child: *mut *mut bwRTreeNode_t,
}
#[test]
fn bindgen_test_layout_bwRTreeNode_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<bwRTreeNode_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(bwRTreeNode_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<bwRTreeNode_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(bwRTreeNode_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<bwRTreeNode_t__bindgen_ty_1>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTreeNode_t__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<bwRTreeNode_t__bindgen_ty_1>())).child as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTreeNode_t__bindgen_ty_1),
            "::",
            stringify!(child)
        )
    );
}
#[test]
fn bindgen_test_layout_bwRTreeNode_t() {
    assert_eq!(
        ::std::mem::size_of::<bwRTreeNode_t>(),
        56usize,
        concat!("Size of: ", stringify!(bwRTreeNode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bwRTreeNode_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bwRTreeNode_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTreeNode_t>())).isLeaf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTreeNode_t),
            "::",
            stringify!(isLeaf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTreeNode_t>())).nChildren as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTreeNode_t),
            "::",
            stringify!(nChildren)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTreeNode_t>())).chrIdxStart as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTreeNode_t),
            "::",
            stringify!(chrIdxStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTreeNode_t>())).baseStart as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTreeNode_t),
            "::",
            stringify!(baseStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTreeNode_t>())).chrIdxEnd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTreeNode_t),
            "::",
            stringify!(chrIdxEnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTreeNode_t>())).baseEnd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTreeNode_t),
            "::",
            stringify!(baseEnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTreeNode_t>())).dataOffset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTreeNode_t),
            "::",
            stringify!(dataOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTreeNode_t>())).x as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTreeNode_t),
            "::",
            stringify!(x)
        )
    );
}
#[doc = " A header and index that points to an R-tree that in turn points to data blocks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bwRTree_t {
    #[doc = "<The maximum number of children a node can have"]
    pub blockSize: u32,
    #[doc = "<The total number of data blocks pointed to by the tree. This is completely redundant."]
    pub nItems: u64,
    #[doc = "<The index to the first chromosome described."]
    pub chrIdxStart: u32,
    #[doc = "<The first position on chrIdxStart with a value."]
    pub baseStart: u32,
    #[doc = "<The index of the last chromosome with an entry."]
    pub chrIdxEnd: u32,
    #[doc = "<The last position on chrIdxEnd with an entry."]
    pub baseEnd: u32,
    #[doc = "<This is actually the offset of the index rather than the size?!? Yes, it's completely redundant."]
    pub idxSize: u64,
    #[doc = "<This is always 1!"]
    pub nItemsPerSlot: u32,
    #[doc = "<The offset to the root node of the R-Tree (on disk). Yes, this is redundant."]
    pub rootOffset: u64,
    #[doc = "<A pointer to the root node."]
    pub root: *mut bwRTreeNode_t,
}
#[test]
fn bindgen_test_layout_bwRTree_t() {
    assert_eq!(
        ::std::mem::size_of::<bwRTree_t>(),
        64usize,
        concat!("Size of: ", stringify!(bwRTree_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bwRTree_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bwRTree_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTree_t>())).blockSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTree_t),
            "::",
            stringify!(blockSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTree_t>())).nItems as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTree_t),
            "::",
            stringify!(nItems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTree_t>())).chrIdxStart as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTree_t),
            "::",
            stringify!(chrIdxStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTree_t>())).baseStart as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTree_t),
            "::",
            stringify!(baseStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTree_t>())).chrIdxEnd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTree_t),
            "::",
            stringify!(chrIdxEnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTree_t>())).baseEnd as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTree_t),
            "::",
            stringify!(baseEnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTree_t>())).idxSize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTree_t),
            "::",
            stringify!(idxSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTree_t>())).nItemsPerSlot as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTree_t),
            "::",
            stringify!(nItemsPerSlot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTree_t>())).rootOffset as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTree_t),
            "::",
            stringify!(rootOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwRTree_t>())).root as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bwRTree_t),
            "::",
            stringify!(root)
        )
    );
}
pub type uLong = ::std::os::raw::c_ulong;
pub type uLongf = uLong;
#[doc = "< This does nothing"]
pub const bwStatsType_doesNotExist: bwStatsType = -1;
#[doc = "< The mean value"]
pub const bwStatsType_mean: bwStatsType = 0;
#[doc = "< The mean value"]
pub const bwStatsType_average: bwStatsType = 0;
#[doc = "< The standard deviation of the values"]
pub const bwStatsType_stdev: bwStatsType = 1;
#[doc = "< The standard deviation of the values"]
pub const bwStatsType_dev: bwStatsType = 1;
#[doc = "< The maximum value"]
pub const bwStatsType_max: bwStatsType = 2;
#[doc = "< The minimum value"]
pub const bwStatsType_min: bwStatsType = 3;
#[doc = "< The number of bases covered"]
pub const bwStatsType_cov: bwStatsType = 4;
#[doc = "<The number of bases covered"]
pub const bwStatsType_coverage: bwStatsType = 4;
#[doc = "< The sum of per-base values"]
pub const bwStatsType_sum: bwStatsType = 5;
#[doc = " An enum that dictates the type of statistic to fetch for a given interval"]
pub type bwStatsType = ::std::os::raw::c_int;
#[doc = " @brief BigWig files have multiple \"zoom\" levels, each of which has its own header. This hold those headers"]
#[doc = ""]
#[doc = " N.B., there's 4 bytes of padding in the on disk representation of level and dataOffset."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bwZoomHdr_t {
    #[doc = "<The zoom level, which is an integer starting with 0."]
    pub level: *mut u32,
    #[doc = "<The offset to the on-disk start of the data. This isn't used currently."]
    pub dataOffset: *mut u64,
    #[doc = "<The offset to the on-disk start of the index. This *is* used."]
    pub indexOffset: *mut u64,
    #[doc = "<Index for each zoom level. Represented as a tree"]
    pub idx: *mut *mut bwRTree_t,
}
#[test]
fn bindgen_test_layout_bwZoomHdr_t() {
    assert_eq!(
        ::std::mem::size_of::<bwZoomHdr_t>(),
        32usize,
        concat!("Size of: ", stringify!(bwZoomHdr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bwZoomHdr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bwZoomHdr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwZoomHdr_t>())).level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bwZoomHdr_t),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwZoomHdr_t>())).dataOffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bwZoomHdr_t),
            "::",
            stringify!(dataOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwZoomHdr_t>())).indexOffset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bwZoomHdr_t),
            "::",
            stringify!(indexOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwZoomHdr_t>())).idx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bwZoomHdr_t),
            "::",
            stringify!(idx)
        )
    );
}
#[doc = " @brief The header section of a bigWig file."]
#[doc = ""]
#[doc = " Some of the values aren't currently used for anything. Others may optionally not exist."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bigWigHdr_t {
    #[doc = "<The version information of the file."]
    pub version: u16,
    #[doc = "<The number of \"zoom\" levels."]
    pub nLevels: u16,
    #[doc = "<The offset to the on-disk chromosome tree list."]
    pub ctOffset: u64,
    #[doc = "<The on-disk offset to the first block of data."]
    pub dataOffset: u64,
    #[doc = "<The on-disk offset to the data index."]
    pub indexOffset: u64,
    #[doc = "<Total number of fields."]
    pub fieldCount: u16,
    #[doc = "<Number of fixed-format BED fields."]
    pub definedFieldCount: u16,
    #[doc = "<The on-disk offset to an SQL string. This is unused."]
    pub sqlOffset: u64,
    #[doc = "<If there's a summary, this is the offset to it on the disk."]
    pub summaryOffset: u64,
    #[doc = "<The compression buffer size (if the data is compressed)."]
    pub bufSize: u32,
    #[doc = "<Unused"]
    pub extensionOffset: u64,
    #[doc = "<Pointers to the header for each zoom level."]
    pub zoomHdrs: *mut bwZoomHdr_t,
    #[doc = "<The total bases covered in the file."]
    pub nBasesCovered: u64,
    #[doc = "<The minimum value in the file."]
    pub minVal: f64,
    #[doc = "<The maximum value in the file."]
    pub maxVal: f64,
    #[doc = "<The sum of all values in the file."]
    pub sumData: f64,
    #[doc = "<The sum of the squared values in the file."]
    pub sumSquared: f64,
}
#[test]
fn bindgen_test_layout_bigWigHdr_t() {
    assert_eq!(
        ::std::mem::size_of::<bigWigHdr_t>(),
        120usize,
        concat!("Size of: ", stringify!(bigWigHdr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bigWigHdr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bigWigHdr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).nLevels as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(nLevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).ctOffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(ctOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).dataOffset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(dataOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).indexOffset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(indexOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).fieldCount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(fieldCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).definedFieldCount as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(definedFieldCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).sqlOffset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(sqlOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).summaryOffset as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(summaryOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).bufSize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(bufSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).extensionOffset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(extensionOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).zoomHdrs as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(zoomHdrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).nBasesCovered as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(nBasesCovered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).minVal as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(minVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).maxVal as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(maxVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).sumData as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(sumData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigHdr_t>())).sumSquared as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigHdr_t),
            "::",
            stringify!(sumSquared)
        )
    );
}
#[doc = " @brief Holds the chromosomes and their lengths"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct chromList_t {
    #[doc = "<The number of chromosomes"]
    pub nKeys: i64,
    #[doc = "<A list of null terminated chromosomes"]
    pub chrom: *mut *mut ::std::os::raw::c_char,
    #[doc = "<The lengths of each chromosome"]
    pub len: *mut u32,
}
#[test]
fn bindgen_test_layout_chromList_t() {
    assert_eq!(
        ::std::mem::size_of::<chromList_t>(),
        24usize,
        concat!("Size of: ", stringify!(chromList_t))
    );
    assert_eq!(
        ::std::mem::align_of::<chromList_t>(),
        8usize,
        concat!("Alignment of ", stringify!(chromList_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<chromList_t>())).nKeys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(chromList_t),
            "::",
            stringify!(nKeys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<chromList_t>())).chrom as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(chromList_t),
            "::",
            stringify!(chrom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<chromList_t>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(chromList_t),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bwLL {
    pub node: *mut bwRTreeNode_t,
    pub next: *mut bwLL,
}
#[test]
fn bindgen_test_layout_bwLL() {
    assert_eq!(
        ::std::mem::size_of::<bwLL>(),
        16usize,
        concat!("Size of: ", stringify!(bwLL))
    );
    assert_eq!(
        ::std::mem::align_of::<bwLL>(),
        8usize,
        concat!("Alignment of ", stringify!(bwLL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwLL>())).node as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bwLL),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwLL>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bwLL),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bwZoomBuffer_t {
    pub p: *mut ::std::os::raw::c_void,
    pub l: u32,
    pub m: u32,
    pub next: *mut bwZoomBuffer_t,
}
#[test]
fn bindgen_test_layout_bwZoomBuffer_t() {
    assert_eq!(
        ::std::mem::size_of::<bwZoomBuffer_t>(),
        24usize,
        concat!("Size of: ", stringify!(bwZoomBuffer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bwZoomBuffer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bwZoomBuffer_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwZoomBuffer_t>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bwZoomBuffer_t),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwZoomBuffer_t>())).l as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bwZoomBuffer_t),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwZoomBuffer_t>())).m as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bwZoomBuffer_t),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwZoomBuffer_t>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bwZoomBuffer_t),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " @brief This is only needed for writing bigWig files (and won't be created otherwise)"]
#[doc = " This should be removed from bigWig.h"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bwWriteBuffer_t {
    #[doc = "<The number of blocks written"]
    pub nBlocks: u64,
    #[doc = "<The maximum number of children"]
    pub blockSize: u32,
    #[doc = "<The number of entries processed. This is used for the first contig and determining how the zoom levels are computed"]
    pub nEntries: u64,
    #[doc = "<The running sum of the entry widths for the first contig (again, used for the first contig and computing zoom levels)"]
    pub runningWidthSum: u64,
    #[doc = "<The current TID that's being processed"]
    pub tid: u32,
    #[doc = "<The start position of the block"]
    pub start: u32,
    #[doc = "<The end position of the block"]
    pub end: u32,
    #[doc = "<The span of each entry, if applicable"]
    pub span: u32,
    #[doc = "<The step size, if applicable"]
    pub step: u32,
    #[doc = "<The type of the last entry added"]
    pub ltype: u8,
    #[doc = "<The current size of p. This and the type determine the number of items held"]
    pub l: u32,
    #[doc = "<A buffer of size hdr->bufSize"]
    pub p: *mut ::std::os::raw::c_void,
    #[doc = "<The first index node in the linked list"]
    pub firstIndexNode: *mut bwLL,
    #[doc = "<The last index node in a linked list"]
    pub currentIndexNode: *mut bwLL,
    #[doc = "<The first node in a linked list of leaf nodes"]
    pub firstZoomBuffer: *mut *mut bwZoomBuffer_t,
    #[doc = "<The last node in a linked list of leaf nodes"]
    pub lastZoomBuffer: *mut *mut bwZoomBuffer_t,
    #[doc = "<The number of leaf nodes per zoom level, useful for determining duplicate levels"]
    pub nNodes: *mut u64,
    #[doc = "<The size of the compression buffer"]
    pub compressPsz: uLongf,
    #[doc = "<A compressed buffer of size compressPsz"]
    pub compressP: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_bwWriteBuffer_t() {
    assert_eq!(
        ::std::mem::size_of::<bwWriteBuffer_t>(),
        128usize,
        concat!("Size of: ", stringify!(bwWriteBuffer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bwWriteBuffer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bwWriteBuffer_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).nBlocks as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(nBlocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).blockSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(blockSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).nEntries as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(nEntries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).runningWidthSum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(runningWidthSum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).tid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).start as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).end as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).span as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(span)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).step as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).ltype as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(ltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).l as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).p as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).firstIndexNode as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(firstIndexNode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<bwWriteBuffer_t>())).currentIndexNode as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(currentIndexNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).firstZoomBuffer as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(firstZoomBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).lastZoomBuffer as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(lastZoomBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).nNodes as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(nNodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).compressPsz as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(compressPsz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwWriteBuffer_t>())).compressP as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(bwWriteBuffer_t),
            "::",
            stringify!(compressP)
        )
    );
}
#[doc = " @brief A structure that holds everything needed to access a bigWig file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bigWigFile_t {
    #[doc = "<A pointer that can handle both local and remote files (including a buffer if needed)."]
    pub URL: *mut URL_t,
    #[doc = "<The file header."]
    pub hdr: *mut bigWigHdr_t,
    #[doc = "<A list of chromosome names (the order is the ID)."]
    pub cl: *mut chromList_t,
    #[doc = "<The index for the full dataset."]
    pub idx: *mut bwRTree_t,
    #[doc = "<The buffer used for writing."]
    pub writeBuffer: *mut bwWriteBuffer_t,
    #[doc = "<0: Opened for reading, 1: Opened for writing."]
    pub isWrite: ::std::os::raw::c_int,
    #[doc = "<0: bigWig, 1: bigBed."]
    pub type_: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bigWigFile_t() {
    assert_eq!(
        ::std::mem::size_of::<bigWigFile_t>(),
        48usize,
        concat!("Size of: ", stringify!(bigWigFile_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bigWigFile_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bigWigFile_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigFile_t>())).URL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigFile_t),
            "::",
            stringify!(URL)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigFile_t>())).hdr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigFile_t),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigFile_t>())).cl as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigFile_t),
            "::",
            stringify!(cl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigFile_t>())).idx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigFile_t),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigFile_t>())).writeBuffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigFile_t),
            "::",
            stringify!(writeBuffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigFile_t>())).isWrite as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigFile_t),
            "::",
            stringify!(isWrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bigWigFile_t>())).type_ as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(bigWigFile_t),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " @brief Holds interval:value associations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bwOverlappingIntervals_t {
    #[doc = "<Number of intervals held"]
    pub l: u32,
    #[doc = "<Maximum number of values/intervals the struct can hold"]
    pub m: u32,
    #[doc = "<The start positions (0-based half open)"]
    pub start: *mut u32,
    #[doc = "<The end positions (0-based half open)"]
    pub end: *mut u32,
    #[doc = "<The value associated with each position"]
    pub value: *mut f32,
}
#[test]
fn bindgen_test_layout_bwOverlappingIntervals_t() {
    assert_eq!(
        ::std::mem::size_of::<bwOverlappingIntervals_t>(),
        32usize,
        concat!("Size of: ", stringify!(bwOverlappingIntervals_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bwOverlappingIntervals_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bwOverlappingIntervals_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlappingIntervals_t>())).l as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlappingIntervals_t),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlappingIntervals_t>())).m as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlappingIntervals_t),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlappingIntervals_t>())).start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlappingIntervals_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlappingIntervals_t>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlappingIntervals_t),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlappingIntervals_t>())).value as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlappingIntervals_t),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " @brief Holds interval:str associations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bbOverlappingEntries_t {
    #[doc = "<Number of intervals held"]
    pub l: u32,
    #[doc = "<Maximum number of values/intervals the struct can hold"]
    pub m: u32,
    #[doc = "<The start positions (0-based half open)"]
    pub start: *mut u32,
    #[doc = "<The end positions (0-based half open)"]
    pub end: *mut u32,
    #[doc = "<The strings associated with a given entry."]
    pub str_: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_bbOverlappingEntries_t() {
    assert_eq!(
        ::std::mem::size_of::<bbOverlappingEntries_t>(),
        32usize,
        concat!("Size of: ", stringify!(bbOverlappingEntries_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bbOverlappingEntries_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bbOverlappingEntries_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bbOverlappingEntries_t>())).l as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bbOverlappingEntries_t),
            "::",
            stringify!(l)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bbOverlappingEntries_t>())).m as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bbOverlappingEntries_t),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bbOverlappingEntries_t>())).start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bbOverlappingEntries_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bbOverlappingEntries_t>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bbOverlappingEntries_t),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bbOverlappingEntries_t>())).str_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bbOverlappingEntries_t),
            "::",
            stringify!(str_)
        )
    );
}
#[doc = " @brief A structure to hold iterations"]
#[doc = " One of intervals and entries should be used to access records from bigWig or bigBed files, respectively."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bwOverlapIterator_t {
    #[doc = "<Pointer to the bigWig/bigBed file."]
    pub bw: *mut bigWigFile_t,
    #[doc = "<The contig/chromosome ID."]
    pub tid: u32,
    #[doc = "<Start position of the query interval."]
    pub start: u32,
    #[doc = "<End position of the query interval."]
    pub end: u32,
    #[doc = "<Offset into the blocks."]
    pub offset: u64,
    #[doc = "<Number of blocks to use per iteration."]
    pub blocksPerIteration: u32,
    #[doc = "<For bigBed entries, whether to return the string with the entries."]
    pub withString: ::std::os::raw::c_int,
    #[doc = "<Overlapping blocks."]
    pub blocks: *mut ::std::os::raw::c_void,
    #[doc = "<Overlapping intervals (or NULL)."]
    pub intervals: *mut bwOverlappingIntervals_t,
    #[doc = "<Overlapping entries (or NULL)."]
    pub entries: *mut bbOverlappingEntries_t,
    #[doc = "<Points to either intervals or entries. If there are no further intervals/entries, then this is NULL. Use this to test for whether to continue iterating."]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_bwOverlapIterator_t() {
    assert_eq!(
        ::std::mem::size_of::<bwOverlapIterator_t>(),
        72usize,
        concat!("Size of: ", stringify!(bwOverlapIterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bwOverlapIterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(bwOverlapIterator_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlapIterator_t>())).bw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlapIterator_t),
            "::",
            stringify!(bw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlapIterator_t>())).tid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlapIterator_t),
            "::",
            stringify!(tid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlapIterator_t>())).start as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlapIterator_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlapIterator_t>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlapIterator_t),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlapIterator_t>())).offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlapIterator_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<bwOverlapIterator_t>())).blocksPerIteration as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlapIterator_t),
            "::",
            stringify!(blocksPerIteration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlapIterator_t>())).withString as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlapIterator_t),
            "::",
            stringify!(withString)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlapIterator_t>())).blocks as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlapIterator_t),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlapIterator_t>())).intervals as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlapIterator_t),
            "::",
            stringify!(intervals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlapIterator_t>())).entries as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlapIterator_t),
            "::",
            stringify!(entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bwOverlapIterator_t>())).data as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bwOverlapIterator_t),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " @brief Initializes curl and global variables. This *MUST* be called before other functions (at least if you want to connect to remote files)."]
    #[doc = " For remote file, curl must be initialized and regions of a file read into an internal buffer. If the buffer is too small then an excessive number of connections will be made. If the buffer is too large than more data than required is fetched. 128KiB is likely sufficient for most needs."]
    #[doc = " @param bufSize The internal buffer size used for remote connection."]
    #[doc = " @see bwCleanup"]
    #[doc = " @return 0 on success and 1 on error."]
    pub fn bwInit(bufSize: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief The counterpart to bwInit, this cleans up curl."]
    #[doc = " @see bwInit"]
    pub fn bwCleanup();
}
extern "C" {
    #[doc = " @brief Determine if a file is a bigWig file."]
    #[doc = " This function will quickly check either local or remote files to determine if they appear to be valid bigWig files. This can be determined by reading the first 4 bytes of the file."]
    #[doc = " @param fname The file name or URL (http, https, and ftp are supported)"]
    #[doc = " @param callBack An optional user-supplied function. This is applied to remote connections so users can specify things like proxy and password information. See `test/testRemote` for an example."]
    #[doc = " @return 1 if the file appears to be bigWig, otherwise 0."]
    pub fn bwIsBigWig(
        fname: *mut ::std::os::raw::c_char,
        callBack: ::std::option::Option<unsafe extern "C" fn(arg1: *mut CURL) -> CURLcode>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Opens a local or remote bigWig file."]
    #[doc = " This will open a local or remote bigWig file. Writing of local bigWig files is also supported."]
    #[doc = " @param fname The file name or URL (http, https, and ftp are supported)"]
    #[doc = " @param callBack An optional user-supplied function. This is applied to remote connections so users can specify things like proxy and password information. See `test/testRemote` for an example."]
    #[doc = " @param mode The mode, by default \"r\". Both local and remote files can be read, but only local files can be written. For files being written the callback function is ignored. If and only if the mode contains \"w\" will the file be opened for writing (in all other cases the file will be opened for reading."]
    #[doc = " @return A bigWigFile_t * on success and NULL on error."]
    pub fn bwOpen(
        fname: *mut ::std::os::raw::c_char,
        callBack: ::std::option::Option<unsafe extern "C" fn(arg1: *mut CURL) -> CURLcode>,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut bigWigFile_t;
}
extern "C" {
    #[doc = " @brief Closes a bigWigFile_t and frees up allocated memory"]
    #[doc = " This closes both bigWig and bigBed files."]
    #[doc = " @param fp The file pointer."]
    pub fn bwClose(fp: *mut bigWigFile_t);
}
extern "C" {
    #[doc = " @brief Converts between chromosome name and ID"]
    #[doc = ""]
    #[doc = " @param fp A valid bigWigFile_t pointer"]
    #[doc = " @param chrom A chromosome name"]
    #[doc = " @return An ID, -1 will be returned on error (note that this is an unsigned value, so that's ~4 billion. bigWig/bigBed files can't store that many chromosomes anyway."]
    pub fn bwGetTid(fp: *mut bigWigFile_t, chrom: *mut ::std::os::raw::c_char) -> u32;
}
extern "C" {
    #[doc = " @brief Frees space allocated by `bwGetOverlappingIntervals`"]
    #[doc = " @param o A valid `bwOverlappingIntervals_t` pointer."]
    #[doc = " @see bwGetOverlappingIntervals"]
    pub fn bwDestroyOverlappingIntervals(o: *mut bwOverlappingIntervals_t);
}
extern "C" {
    #[doc = " @brief Return bigWig entries overlapping an interval."]
    #[doc = " Find all bigWig entries overlapping a range and returns them, including their associated values."]
    #[doc = " @param fp A valid bigWigFile_t pointer. This MUST be for a bigWig file!"]
    #[doc = " @param chrom A valid chromosome name."]
    #[doc = " @param start The start position of the interval. This is 0-based half open, so 0 is the first base."]
    #[doc = " @param end The end position of the interval. Again, this is 0-based half open, so 100 will include the 100th base...which is at position 99."]
    #[doc = " @return NULL on error or no overlapping values, otherwise a `bwOverlappingIntervals_t *` holding the values and intervals."]
    #[doc = " @see bwOverlappingIntervals_t"]
    #[doc = " @see bwDestroyOverlappingIntervals"]
    #[doc = " @see bwGetValues"]
    pub fn bwGetOverlappingIntervals(
        fp: *mut bigWigFile_t,
        chrom: *mut ::std::os::raw::c_char,
        start: u32,
        end: u32,
    ) -> *mut bwOverlappingIntervals_t;
}
extern "C" {
    #[doc = " @brief Creates an iterator over intervals in a bigWig file"]
    #[doc = " Iterators can be traversed with `bwIteratorNext()` and destroyed with `bwIteratorDestroy()`."]
    #[doc = " Intervals are in the `intervals` member and `data` can be used to determine when to end iteration."]
    #[doc = " @param fp A valid bigWigFile_t pointer. This MUST be for a bigWig file!"]
    #[doc = " @param chrom A valid chromosome name."]
    #[doc = " @param start The start position of the interval. This is 0-based half open, so 0 is the first base."]
    #[doc = " @param end The end position of the interval. Again, this is 0-based half open, so 100 will include the 100th base...which is at position 99."]
    #[doc = " @param blocksPerIteration The number of blocks (internal groupings of intervals in bigWig files) to return per iteration."]
    #[doc = " @return NULL on error, otherwise a bwOverlapIterator_t pointer"]
    #[doc = " @see bwOverlapIterator_t"]
    #[doc = " @see bwIteratorNext"]
    #[doc = " @see bwIteratorDestroy"]
    pub fn bwOverlappingIntervalsIterator(
        fp: *mut bigWigFile_t,
        chrom: *mut ::std::os::raw::c_char,
        start: u32,
        end: u32,
        blocksPerIteration: u32,
    ) -> *mut bwOverlapIterator_t;
}
extern "C" {
    #[doc = " @brief Traverses to the entries/intervals in the next group of blocks."]
    #[doc = " @param iter A bwOverlapIterator_t pointer that is updated (or destroyed on error)"]
    #[doc = " @return NULL on error, otherwise a bwOverlapIterator_t pointer with the intervals or entries from the next set of blocks."]
    #[doc = " @see bwOverlapIterator_t"]
    #[doc = " @see bwIteratorDestroy"]
    pub fn bwIteratorNext(iter: *mut bwOverlapIterator_t) -> *mut bwOverlapIterator_t;
}
extern "C" {
    #[doc = " @brief Destroys a bwOverlapIterator_t"]
    #[doc = " @param iter The bwOverlapIterator_t that should be destroyed"]
    pub fn bwIteratorDestroy(iter: *mut bwOverlapIterator_t);
}
extern "C" {
    #[doc = " @brief Return all per-base bigWig values in a given interval."]
    #[doc = " Given an interval (e.g., chr1:0-100), return the value at each position in a bigWig file. Positions without associated values are suppressed by default, but may be returned if `includeNA` is not 0."]
    #[doc = " @param fp A valid bigWigFile_t pointer."]
    #[doc = " @param chrom A valid chromosome name."]
    #[doc = " @param start The start position of the interval. This is 0-based half open, so 0 is the first base."]
    #[doc = " @param end The end position of the interval. Again, this is 0-based half open, so 100 will include the 100th base...which is at position 99."]
    #[doc = " @param includeNA If not 0, report NA values as well (as NA)."]
    #[doc = " @return NULL on error or no overlapping values, otherwise a `bwOverlappingIntervals_t *` holding the values and positions."]
    #[doc = " @see bwOverlappingIntervals_t"]
    #[doc = " @see bwDestroyOverlappingIntervals"]
    #[doc = " @see bwGetOverlappingIntervals"]
    pub fn bwGetValues(
        fp: *mut bigWigFile_t,
        chrom: *mut ::std::os::raw::c_char,
        start: u32,
        end: u32,
        includeNA: ::std::os::raw::c_int,
    ) -> *mut bwOverlappingIntervals_t;
}
extern "C" {
    #[doc = " @brief Determines per-interval bigWig statistics"]
    #[doc = " Can determine mean/min/max/coverage/standard deviation of values in one or more intervals in a bigWig file. You can optionally give it an interval and ask for values from X number of sub-intervals."]
    #[doc = " @param fp The file from which to extract statistics."]
    #[doc = " @param chrom A valid chromosome name."]
    #[doc = " @param start The start position of the interval. This is 0-based half open, so 0 is the first base."]
    #[doc = " @param end The end position of the interval. Again, this is 0-based half open, so 100 will include the 100th base...which is at position 99."]
    #[doc = " @param nBins The number of bins within the interval to calculate statistics for."]
    #[doc = " @param type The type of statistic."]
    #[doc = " @see bwStatsType"]
    #[doc = " @return A pointer to an array of double precission floating point values. Note that bigWig files only hold 32-bit values, so this is done to help prevent overflows."]
    pub fn bwStats(
        fp: *mut bigWigFile_t,
        chrom: *mut ::std::os::raw::c_char,
        start: u32,
        end: u32,
        nBins: u32,
        type_: bwStatsType,
    ) -> *mut f64;
}
extern "C" {
    #[doc = " @brief Determines per-interval bigWig statistics"]
    #[doc = " Can determine mean/min/max/coverage/standard deviation of values in one or more intervals in a bigWig file. You can optionally give it an interval and ask for values from X number of sub-intervals. The difference with bwStats is that zoom levels are never used."]
    #[doc = " @param fp The file from which to extract statistics."]
    #[doc = " @param chrom A valid chromosome name."]
    #[doc = " @param start The start position of the interval. This is 0-based half open, so 0 is the first base."]
    #[doc = " @param end The end position of the interval. Again, this is 0-based half open, so 100 will include the 100th base...which is at position 99."]
    #[doc = " @param nBins The number of bins within the interval to calculate statistics for."]
    #[doc = " @param type The type of statistic."]
    #[doc = " @see bwStatsType"]
    #[doc = " @return A pointer to an array of double precission floating point values. Note that bigWig files only hold 32-bit values, so this is done to help prevent overflows."]
    pub fn bwStatsFromFull(
        fp: *mut bigWigFile_t,
        chrom: *mut ::std::os::raw::c_char,
        start: u32,
        end: u32,
        nBins: u32,
        type_: bwStatsType,
    ) -> *mut f64;
}
extern "C" {
    #[doc = " @brief Create a largely empty bigWig header"]
    #[doc = " Every bigWig file has a header, this creates the template for one. It also takes care of space allocation in the output write buffer."]
    #[doc = " @param fp The bigWigFile_t* that you want to write to."]
    #[doc = " @param maxZooms The maximum number of zoom levels. If you specify 0 then there will be no zoom levels. A value <0 or > 65535 will result in a maximum of 10."]
    #[doc = " @return 0 on success."]
    pub fn bwCreateHdr(fp: *mut bigWigFile_t, maxZooms: i32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Take a list of chromosome names and lengths and return a pointer to a chromList_t"]
    #[doc = " This MUST be run before `bwWriteHdr()`. Note that the input is NOT free()d!"]
    #[doc = " @param chroms A list of chromosomes."]
    #[doc = " @param lengths The length of each chromosome."]
    #[doc = " @param n The number of chromosomes (thus, the length of `chroms` and `lengths`)"]
    #[doc = " @return A pointer to a chromList_t or NULL on error."]
    pub fn bwCreateChromList(
        chroms: *mut *mut ::std::os::raw::c_char,
        lengths: *mut u32,
        n: i64,
    ) -> *mut chromList_t;
}
extern "C" {
    #[doc = " @brief Write a the header to a bigWig file."]
    #[doc = " You must have already opened the output file, created a header and a chromosome list."]
    #[doc = " @param bw The output bigWigFile_t pointer."]
    #[doc = " @see bwCreateHdr"]
    #[doc = " @see bwCreateChromList"]
    pub fn bwWriteHdr(bw: *mut bigWigFile_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Write a new block of bedGraph-like intervals to a bigWig file"]
    #[doc = " Adds entries of the form:"]
    #[doc = " chromosome\tstart\tend\tvalue"]
    #[doc = " to the file. These will always be added in a new block, so you may have previously used a different storage type."]
    #[doc = ""]
    #[doc = " In general it's more efficient to use the bwAppend* functions, but then you MUST know that the previously written block is of the same type. In other words, you can only use bwAppendIntervals() after bwAddIntervals() or a previous bwAppendIntervals()."]
    #[doc = " @param fp The output file pointer."]
    #[doc = " @param chrom A list of chromosomes, of length `n`."]
    #[doc = " @param start A list of start positions of length`n`."]
    #[doc = " @param end A list of end positions of length`n`."]
    #[doc = " @param values A list of values of length`n`."]
    #[doc = " @param n The length of the aforementioned lists."]
    #[doc = " @return 0 on success and another value on error."]
    #[doc = " @see bwAppendIntervals"]
    pub fn bwAddIntervals(
        fp: *mut bigWigFile_t,
        chrom: *mut *mut ::std::os::raw::c_char,
        start: *mut u32,
        end: *mut u32,
        values: *mut f32,
        n: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Append bedGraph-like intervals to a previous block of bedGraph-like intervals in a bigWig file."]
    #[doc = " If you have previously used bwAddIntervals() then this will append additional entries into the previous block (or start a new one if needed)."]
    #[doc = " @param fp The output file pointer."]
    #[doc = " @param start A list of start positions of length`n`."]
    #[doc = " @param end A list of end positions of length`n`."]
    #[doc = " @param values A list of values of length`n`."]
    #[doc = " @param n The length of the aforementioned lists."]
    #[doc = " @return 0 on success and another value on error."]
    #[doc = " @warning Do NOT use this after `bwAddIntervalSpanSteps()`, `bwAppendIntervalSpanSteps()`, `bwAddIntervalSpanSteps()`, or `bwAppendIntervalSpanSteps()`."]
    #[doc = " @see bwAddIntervals"]
    pub fn bwAppendIntervals(
        fp: *mut bigWigFile_t,
        start: *mut u32,
        end: *mut u32,
        values: *mut f32,
        n: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add a new block of variable-step entries to a bigWig file"]
    #[doc = " Adds entries for the form"]
    #[doc = " chromosome\tstart\tvalue"]
    #[doc = " to the file. Each block of such entries has an associated \"span\", so each value describes the region chromosome:start-(start+span)"]
    #[doc = ""]
    #[doc = " This will always start a new block of values."]
    #[doc = " @param fp The output file pointer."]
    #[doc = " @param chrom A list of chromosomes, of length `n`."]
    #[doc = " @param start A list of start positions of length`n`."]
    #[doc = " @param span The span of each entry (the must all be the same)."]
    #[doc = " @param values A list of values of length`n`."]
    #[doc = " @param n The length of the aforementioned lists."]
    #[doc = " @return 0 on success and another value on error."]
    #[doc = " @see bwAppendIntervalSpans"]
    pub fn bwAddIntervalSpans(
        fp: *mut bigWigFile_t,
        chrom: *mut ::std::os::raw::c_char,
        start: *mut u32,
        span: u32,
        values: *mut f32,
        n: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Append to a previous block of variable-step entries."]
    #[doc = " If you previously used `bwAddIntervalSpans()`, this will continue appending more values to the block(s) it created."]
    #[doc = " @param fp The output file pointer."]
    #[doc = " @param start A list of start positions of length`n`."]
    #[doc = " @param values A list of values of length`n`."]
    #[doc = " @param n The length of the aforementioned lists."]
    #[doc = " @return 0 on success and another value on error."]
    #[doc = " @warning Do NOT use this after `bwAddIntervals()`, `bwAppendIntervals()`, `bwAddIntervalSpanSteps()` or `bwAppendIntervalSpanSteps()`"]
    #[doc = " @see bwAddIntervalSpans"]
    pub fn bwAppendIntervalSpans(
        fp: *mut bigWigFile_t,
        start: *mut u32,
        values: *mut f32,
        n: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add a new block of fixed-step entries to a bigWig file"]
    #[doc = " Adds entries for the form"]
    #[doc = " value"]
    #[doc = " to the file. Each block of such entries has an associated \"span\", \"step\", chromosome and start position. See the wiggle format for more details."]
    #[doc = ""]
    #[doc = " This will always start a new block of values."]
    #[doc = " @param fp The output file pointer."]
    #[doc = " @param chrom The chromosome that the entries describe."]
    #[doc = " @param start The starting position of the block of entries."]
    #[doc = " @param span The span of each entry (i.e., the number of bases it describes)."]
    #[doc = " @param step The step between entry start positions."]
    #[doc = " @param values A list of values of length`n`."]
    #[doc = " @param n The length of the aforementioned lists."]
    #[doc = " @return 0 on success and another value on error."]
    #[doc = " @see bwAddIntervalSpanSteps"]
    pub fn bwAddIntervalSpanSteps(
        fp: *mut bigWigFile_t,
        chrom: *mut ::std::os::raw::c_char,
        start: u32,
        span: u32,
        step: u32,
        values: *mut f32,
        n: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Append to a previous block of fixed-step entries."]
    #[doc = " If you previously used `bwAddIntervalSpanSteps()`, this will continue appending more values to the block(s) it created."]
    #[doc = " @param fp The output file pointer."]
    #[doc = " @param values A list of values of length`n`."]
    #[doc = " @param n The length of the aforementioned lists."]
    #[doc = " @return 0 on success and another value on error."]
    #[doc = " @warning Do NOT use this after `bwAddIntervals()`, `bwAppendIntervals()`, `bwAddIntervalSpans()` or `bwAppendIntervalSpans()`"]
    #[doc = " @see bwAddIntervalSpanSteps"]
    pub fn bwAppendIntervalSpanSteps(
        fp: *mut bigWigFile_t,
        values: *mut f32,
        n: u32,
    ) -> ::std::os::raw::c_int;
}
